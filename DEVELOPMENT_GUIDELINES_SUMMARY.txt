â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                â•‘
â•‘               âœ… DEVELOPMENT GUIDELINES - ENFORCED FROM NOW ON âœ…              â•‘
â•‘                                                                                â•‘
â•‘                  These standards MUST be followed on all work                  â•‘
â•‘                                                                                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“‹ CORE PRINCIPLES (Must Follow)

1. DRY (Don't Repeat Yourself)
   âœ… Extract repeated code into utilities, constants, or hooks
   âœ… Create shared functions instead of copy-pasting
   âœ… One source of truth for calculations, options, and types
   âŒ Never duplicate logic across files

2. Single Responsibility Principle
   âœ… Each function/component does ONE thing well
   âœ… Break complex components into smaller pieces
   âœ… Keep components focused and maintainable
   âŒ Don't create "god components" that do everything

3. KISS (Keep It Simple, Stupid)
   âœ… Write clear, readable code
   âœ… Choose simplicity over cleverness
   âœ… If it needs explaining, it's too complex
   âŒ Don't over-engineer solutions

4. YAGNI (You Aren't Gonna Need It)
   âœ… Build what's needed now
   âœ… Refactor when requirements change
   âœ… Focus on core requirements
   âŒ Don't add "just in case" features

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ WHERE TO PUT CODE

Use utils/ for:
âœ… Pure functions with no side effects
âœ… Calculations, formatting, validation
âœ… Example: calculatePnL(), formatCurrency()

Use hooks/ for:
âœ… React-specific logic (state, effects, context)
âœ… Stateful and reusable logic
âœ… Example: useTemporaryMessage(), useApiCall()

Use constants/ for:
âœ… Configuration values and option lists
âœ… Constant values used in multiple places
âœ… Example: STAKING_PROVIDERS, ASSET_OPTIONS

Use types/ for:
âœ… TypeScript type definitions
âœ… Interfaces and type aliases
âœ… Example: Position interface, CloseableProps

Keep in components/ for:
âœ… Component-specific logic ONLY
âœ… Render logic
âŒ DON'T put utility functions here
âŒ DON'T put constants here

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… BEFORE WRITING ANY CODE - CHECKLIST

Ask yourself these questions:

â–¡ Does this logic already exist somewhere?
  â†’ If yes, reuse it or extract it to a shared utility

â–¡ Should this be a hook, utility, or constant?
  â†’ Hook: React logic with state/effects
  â†’ Utility: Pure function with no side effects
  â†’ Constant: Configuration or option values

â–¡ Can this be reused in other components?
  â†’ If yes, put it in utils/, hooks/, or constants/
  â†’ If no, keep it local to the component

â–¡ Does this violate DRY principle?
  â†’ Check for duplicate patterns
  â†’ Check for duplicate constants
  â†’ Check for duplicate type definitions

â–¡ Is this the simplest possible implementation?
  â†’ Avoid over-engineering
  â†’ Don't add unnecessary features
  â†’ Focus on core requirement only

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ CODE QUALITY STANDARDS

Size Limits:
â€¢ Components: < 300 lines
â€¢ Functions: < 50 lines
â€¢ Line length: < 100 characters

Type Safety:
â€¢ âœ… Always use TypeScript types
â€¢ âœ… Type all parameters and return values
â€¢ âœ… Type all React props
â€¢ âŒ Never use `any` type
â€¢ âŒ No untyped functions

Documentation:
â€¢ âœ… JSDoc comments for public functions
â€¢ âœ… Comments for complex logic
â€¢ âœ… Clear, descriptive variable names
â€¢ âŒ No magic numbers or values
â€¢ âŒ No commented-out code

Naming Conventions:
â€¢ Components: PascalCase (PositionCard.tsx)
â€¢ Hooks: camelCase with use prefix (useTemporaryMessage.ts)
â€¢ Utils/Functions: camelCase (calculations.ts)
â€¢ Constants: SCREAMING_SNAKE_CASE (ASSET_OPTIONS)
â€¢ Types: PascalCase (trading.ts, common.ts)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ” CODE REVIEW CHECKLIST (Before Committing)

Before you commit code, verify ALL of these:

â–¡ DRY: No duplicate logic, constants, or types
â–¡ Organization: Code in correct folder/file
â–¡ Naming: Clear, consistent, descriptive names
â–¡ Types: All parameters and returns typed
â–¡ Documentation: Functions have JSDoc comments
â–¡ Size: Components < 300 lines, functions < 50 lines
â–¡ Performance: No unnecessary renders or calculations
â–¡ Linting: Passes linter without errors/warnings
â–¡ Tests: New logic has appropriate test coverage
â–¡ Accessibility: Proper semantic HTML, ARIA labels

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âš ï¸  COMMON MISTAKES TO AVOID

Mistake 1: Duplicating Logic
âŒ BAD: const pnl = value - shares * price (in multiple files)
âœ… GOOD: import { calculatePnL } from '../utils/calculations'

Mistake 2: Duplicating Constants
âŒ BAD: const ASSETS = ['BTC', 'ETH', 'SPY'] (in multiple files)
âœ… GOOD: import { ASSET_OPTIONS } from '../constants/options'

Mistake 3: Unclear Responsibilities
âŒ BAD: One component does fetching, validating, calculating, rendering
âœ… GOOD: Split into specialized components with focused purposes

Mistake 4: No Type Safety
âŒ BAD: function processData(data) { return data.map(d => d.value) }
âœ… GOOD: function processData(data: Item[]): number[] { ... }

Mistake 5: Magic Numbers
âŒ BAD: signals.filter(s => s.confidence > 0.8)
âœ… GOOD: const CONFIDENCE_THRESHOLD = 0.8; filter(s => s.confidence > CONFIDENCE_THRESHOLD)

Mistake 6: Using `any` Type
âŒ BAD: function calc(data: any): any { ... }
âœ… GOOD: function calc(data: Order[]): number { ... }

Mistake 7: Putting Utils in Components
âŒ BAD: Define utility functions inside components
âœ… GOOD: Move to utils/ and import

Mistake 8: Hardcoding Values
âŒ BAD: if (role === 'admin' || role === 'moderator' || role === 'editor')
âœ… GOOD: const ADMIN_ROLES = ['admin', 'moderator', 'editor']; if (ADMIN_ROLES.includes(role))

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ”„ WORKFLOW FOR NEW FEATURES

1. DESIGN PHASE
   â–¡ Define requirements clearly
   â–¡ Check if logic already exists
   â–¡ Plan component structure
   â–¡ Identify what can be reused

2. IMPLEMENTATION PHASE
   â–¡ Extract utilities first
   â–¡ Create constants for config
   â–¡ Define TypeScript types
   â–¡ Build components using utilities

3. TESTING PHASE
   â–¡ Test utilities thoroughly
   â–¡ Test components
   â–¡ Test integration
   â–¡ Manual QA

4. REVIEW PHASE
   â–¡ Self-review with checklist above
   â–¡ Check for duplicates
   â–¡ Verify organization
   â–¡ Confirm documentation complete

5. COMMIT PHASE
   â–¡ Write clear commit message
   â–¡ Run linter/tests
   â–¡ Ensure all checks pass
   â–¡ Commit with confidence

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Š METRICS TO MAINTAIN

Monitor these to keep code healthy:

Code Duplication:        Must be < 1%      (currently 0%)
Average Component Size:  Should be < 200   (lines)
Average Function Size:   Should be < 40    (lines)
Type Coverage:           Must be 100%      (no `any` types)
Test Coverage:           Aim for > 80%     (on touched modules)
Linting Errors:          Must be 0         (zero tolerance)
Linting Warnings:        Must be 0         (zero tolerance)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ QUICK REFERENCE

When you need to...                         Look here...
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Use a calculation function                  utils/calculations.ts
Save/load from localStorage                 utils/storage.ts
Use staking provider options                constants/options.ts
Auto-dismiss a message                      hooks/useTemporaryMessage.ts
Define common prop interfaces               types/common.ts
See how components should be structured     CODING_STANDARDS_AND_BEST_PRACTICES.md
Get quick reference on new utilities        CLEANUP_QUICK_REFERENCE.md
Understand the cleanup that was done        CLEANUP_IMPLEMENTATION_COMPLETE.md

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ WHEN IN DOUBT

1. Check existing patterns in the codebase
2. Refer to CODING_STANDARDS_AND_BEST_PRACTICES.md
3. Ask yourself: "Is there a better way to organize this?"
4. Prioritize: CLARITY > CLEVERNESS
5. Remember: Code is read more often than it's written

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… ENFORCEMENT

These standards are MANDATORY for:
âœ… All new features
âœ… All bug fixes
âœ… All refactoring work
âœ… Code reviews
âœ… Pull requests

Violations should be caught in:
âœ… Self-review before committing
âœ… Linting (ruff, eslint)
âœ… Type checking (TypeScript)
âœ… Code review process

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ¯ OUR COMMITMENT

By following these guidelines, we ensure:

âœ¨ Clean, organized codebase
âœ¨ Reduced technical debt
âœ¨ Easier maintenance and debugging
âœ¨ Faster feature development
âœ¨ Better team collaboration
âœ¨ Production-ready code quality
âœ¨ Sustainable growth

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Generated: November 2, 2025
Status: Active & Enforced
Authority: Required for all development
Last Review: Post-Cleanup Phase 3

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                â•‘
â•‘                    These guidelines protect code quality!                      â•‘
â•‘               Follow them for a clean, scalable codebase.                      â•‘
â•‘                                                                                â•‘
â•‘                        Happy coding! ğŸš€                                        â•‘
â•‘                                                                                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
